<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Top-Down Stealth (Vanilla JS)</title>
  <style>
    body { margin: 0; background:#0b0f14; color:#e6edf3; font-family: system-ui, sans-serif; }
    #wrap { display:flex; gap:16px; padding:16px; align-items:flex-start; }
    canvas { background:#0f1621; border:1px solid #243244; border-radius:12px; }
    .panel { width: 260px; }
    .hud { padding:12px; border:1px solid #243244; border-radius:12px; background:#0f1621; }
    .row { display:flex; justify-content:space-between; margin:8px 0; }
    .bar { height:10px; background:#243244; border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:50%; background:#2f81f7; }
    .hint { opacity:0.85; font-size: 0.9rem; line-height:1.35; margin-top:12px; }
    .dangerFlash { animation: flash 180ms ease-in-out; }
    @keyframes flash { from { filter: brightness(1.6); } to { filter: brightness(1); } }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="768" height="512"></canvas>
  <div class="panel">
    <div class="hud" id="hud">
      <div class="row"><div>Score</div><div id="score">0</div></div>
      <div class="row"><div>Target</div><div id="target">100</div></div>
      <div class="row"><div>Time</div><div id="time">60.0</div></div>

      <div style="margin-top:10px;">Health</div>
      <div class="bar"><div id="hpBar"></div></div>

      <div class="hint">
        Move: WASD / Arrow Keys<br/>
        Tip: break line-of-sight behind walls to lose guards.
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // -----------------------------
  // 0) Utilities
  // -----------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const dist2 = (ax, ay, bx, by) => {
    const dx = bx - ax, dy = by - ay;
    return dx*dx + dy*dy;
  };
  const len = (x, y) => Math.hypot(x, y);
  const norm = (x, y) => {
    const l = Math.hypot(x, y) || 1;
    return { x: x / l, y: y / l };
  };
  const dot = (ax, ay, bx, by) => ax*bx + ay*by;
  const now = () => performance.now();

  // -----------------------------
  // 1) Config
  // -----------------------------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const UI = {
    hud: document.getElementById("hud"),
    score: document.getElementById("score"),
    target: document.getElementById("target"),
    time: document.getElementById("time"),
    hpBar: document.getElementById("hpBar"),
  };

  const TILE = 32; // pixels
  const MAP_W = 24;
  const MAP_H = 16;

  const GAME = {
    targetScore: 100,
    timeLimit: 60, // seconds
    damageLimit: 100, // health is 0..100
  };

  const PLAYER_CFG = {
    radius: 12,
    speed: 160, // px/sec
    maxHP: 100,
    invulnAfterHit: 0.25, // seconds
  };

  const GUARD_CFG = {
    radius: 12,
    patrolSpeed: 95,
    chaseSpeed: 140,
    visionRange: 210,
    coneHalfAngle: Math.PI / 7, // ~25.7 degrees
    dps: 22, // damage per second while in cone & LoS
    loseSightGrace: 1.2, // seconds after losing sight before switching to SEARCH
    searchDuration: 2.0, // seconds to linger at last seen
    turnSmoothing: 10, // higher = snappier direction change
  };

  const POWERUP_CFG = {
    spawnInterval: 3.0,     // seconds between spawn attempts
    maxOnMap: 2,
    ttl: 7.0,               // seconds powerup stays if not collected
    pickupRadius: 16,
    effectDuration: 5.0,
  };

  // -----------------------------
  // 2) Map (labyrinth tiles)
  // 0 = floor, 1 = wall
  // -----------------------------
  // Simple handmade maze-ish layout. Replace with your own generator later.
  const map = [
    "111111111111111111111111",
    "100000000000001000000001",
    "101111011111101011111101",
    "101000010000001010000101",
    "101011110111111010111101",
    "101010000100000010100001",
    "101010111101111110101101",
    "100010100001000000101001",
    "111110101111011111101011",
    "100000101000010000001001",
    "101111101011110111111101",
    "101000001010000100000001",
    "101011111010111101111101",
    "101000000010000001000001",
    "101111111111111111011101",
    "111111111111111111111111",
  ].map(row => row.split("").map(c => c === "1" ? 1 : 0));

  const isWallTile = (tx, ty) => {
    if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return true;
    return map[ty][tx] === 1;
  };

  const worldToTile = (x, y) => ({ tx: Math.floor(x / TILE), ty: Math.floor(y / TILE) });

  // -----------------------------
  // 3) Raycast for line of sight
  // Grid stepping DDA-ish: sample along line in small steps.
  // For higher performance, implement a tile-based DDA.
  // -----------------------------
  function hasLineOfSight(ax, ay, bx, by) {
    const dx = bx - ax, dy = by - ay;
    const d = Math.hypot(dx, dy);
    if (d < 1) return true;

    const steps = Math.ceil(d / 8); // sample every ~8px
    const sx = dx / steps, sy = dy / steps;

    let x = ax, y = ay;
    for (let i = 0; i < steps; i++) {
      const { tx, ty } = worldToTile(x, y);
      if (isWallTile(tx, ty)) return false;
      x += sx; y += sy;
    }
    return true;
  }

  // -----------------------------
  // 4) Collision: circle vs tiles
  // Resolve by pushing out of colliding wall tiles.
  // -----------------------------
  function resolveCircleVsMap(ent) {
    const r = ent.radius;

    // Broad phase: check tiles around the circle
    const minTx = Math.floor((ent.x - r) / TILE);
    const maxTx = Math.floor((ent.x + r) / TILE);
    const minTy = Math.floor((ent.y - r) / TILE);
    const maxTy = Math.floor((ent.y + r) / TILE);

    for (let ty = minTy; ty <= maxTy; ty++) {
      for (let tx = minTx; tx <= maxTx; tx++) {
        if (!isWallTile(tx, ty)) continue;

        // Tile AABB
        const left = tx * TILE, top = ty * TILE;
        const right = left + TILE, bottom = top + TILE;

        // Closest point on AABB to circle center
        const cx = clamp(ent.x, left, right);
        const cy = clamp(ent.y, top, bottom);

        const dx = ent.x - cx, dy = ent.y - cy;
        const d2 = dx*dx + dy*dy;
        if (d2 < r*r) {
          const d = Math.sqrt(d2) || 0.0001;
          const push = (r - d);
          ent.x += (dx / d) * push;
          ent.y += (dy / d) * push;
        }
      }
    }
  }

  // -----------------------------
  // 5) Input
  // -----------------------------
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    keys.add(e.key.toLowerCase());
  });
  window.addEventListener("keyup", (e) => {
    keys.delete(e.key.toLowerCase());
  });

  function getMoveVector() {
    let x = 0, y = 0;
    if (keys.has("w") || keys.has("arrowup")) y -= 1;
    if (keys.has("s") || keys.has("arrowdown")) y += 1;
    if (keys.has("a") || keys.has("arrowleft")) x -= 1;
    if (keys.has("d") || keys.has("arrowright")) x += 1;

    if (x === 0 && y === 0) return { x: 0, y: 0 };
    const n = norm(x, y);
    return n;
  }

  // -----------------------------
  // 6) Entities
  // -----------------------------
  const player = {
    x: 2.5 * TILE,
    y: 2.5 * TILE,
    radius: PLAYER_CFG.radius,
    speed: PLAYER_CFG.speed,
    hp: PLAYER_CFG.maxHP,
    invuln: 0,
    score: 0,
    // power-up effects:
    speedMul: 1,
    scoreMul: 1,
    invisible: 0, // seconds remaining
  };

  function makeGuard(x, y, waypoints) {
    return {
      x, y,
      radius: GUARD_CFG.radius,
      state: "PATROL", // PATROL | CHASE | SEARCH | RETURN
      waypoints,
      wpIndex: 0,
      dirX: 1, dirY: 0, // facing direction
      lastSeenX: x, lastSeenY: y,
      timeSinceSeen: 999,
      searchTimer: 0,
    };
  }

  const guards = [
    makeGuard(18.5*TILE, 2.5*TILE, [
      {x:18.5*TILE, y:2.5*TILE},
      {x:21.5*TILE, y:2.5*TILE},
      {x:21.5*TILE, y:5.5*TILE},
      {x:18.5*TILE, y:5.5*TILE},
    ]),
    makeGuard(6.5*TILE, 11.5*TILE, [
      {x:6.5*TILE, y:11.5*TILE},
      {x:10.5*TILE, y:11.5*TILE},
      {x:10.5*TILE, y:13.5*TILE},
      {x:6.5*TILE, y:13.5*TILE},
    ]),
  ];

  const powerups = []; // {x,y,type,ttl}
  let powerupSpawnTimer = 0;

  // -----------------------------
  // 7) Power-up logic
  // -----------------------------
  const POWER_TYPES = [
    { type: "HEAL",      weight: 2 },
    { type: "SPEED",     weight: 2 },
    { type: "SCOREX2",   weight: 2 },
    { type: "INVIS",     weight: 1 },
  ];

  function pickWeightedPowerType() {
    const total = POWER_TYPES.reduce((s, t) => s + t.weight, 0);
    let r = Math.random() * total;
    for (const t of POWER_TYPES) {
      r -= t.weight;
      if (r <= 0) return t.type;
    }
    return "HEAL";
  }

  function randomFloorPosition() {
    // Try a handful of times to find a good spawn location.
    for (let i = 0; i < 60; i++) {
      const tx = Math.floor(Math.random() * MAP_W);
      const ty = Math.floor(Math.random() * MAP_H);
      if (isWallTile(tx, ty)) continue;

      const x = (tx + 0.5) * TILE;
      const y = (ty + 0.5) * TILE;

      // Not too close to player
      if (dist2(x,y, player.x,player.y) < (TILE*TILE*4)) continue;

      // Not inside walls by radius
      const temp = { x, y, radius: 12 };
      const before = { x, y };
      resolveCircleVsMap(temp);
      const moved = dist2(before.x,before.y, temp.x,temp.y) > 1;
      if (moved) continue;

      return { x, y };
    }
    // fallback near center
    return { x: 12.5*TILE, y: 8.5*TILE };
  }

  function spawnPowerup() {
    if (powerups.length >= POWERUP_CFG.maxOnMap) return;
    const pos = randomFloorPosition();
    powerups.push({
      x: pos.x,
      y: pos.y,
      type: pickWeightedPowerType(),
      ttl: POWERUP_CFG.ttl,
    });
  }

  function applyPowerup(type) {
    // UI feedback: small HUD flash
    UI.hud.classList.add("dangerFlash");
    setTimeout(() => UI.hud.classList.remove("dangerFlash"), 160);

    if (type === "HEAL") {
      player.hp = clamp(player.hp + 30, 0, PLAYER_CFG.maxHP);
      player.score += Math.floor(5 * player.scoreMul);
    } else if (type === "SPEED") {
      player.speedMul = 1.5;
      setTimeout(() => player.speedMul = 1, POWERUP_CFG.effectDuration * 1000);
    } else if (type === "SCOREX2") {
      player.scoreMul = 2;
      setTimeout(() => player.scoreMul = 1, POWERUP_CFG.effectDuration * 1000);
    } else if (type === "INVIS") {
      player.invisible = POWERUP_CFG.effectDuration;
    }
  }

  // -----------------------------
  // 8) Guard vision + state transitions
  // -----------------------------
  function canGuardSeePlayer(g) {
    if (player.invisible > 0) return false;

    const vx = player.x - g.x;
    const vy = player.y - g.y;
    const d = Math.hypot(vx, vy);

    if (d > GUARD_CFG.visionRange) return false;

    const vNorm = { x: vx / (d || 1), y: vy / (d || 1) };
    const dirNorm = norm(g.dirX, g.dirY);

    const c = clamp(dot(vNorm.x, vNorm.y, dirNorm.x, dirNorm.y), -1, 1);
    const angle = Math.acos(c);
    if (angle > GUARD_CFG.coneHalfAngle) return false;

    // Line-of-sight raycast
    return hasLineOfSight(g.x, g.y, player.x, player.y);
  }

  function moveTowards(ent, tx, ty, speed, dt) {
    const dx = tx - ent.x;
    const dy = ty - ent.y;
    const d = Math.hypot(dx, dy);
    if (d < 0.001) return true;

    const vx = dx / d;
    const vy = dy / d;
    ent.x += vx * speed * dt;
    ent.y += vy * speed * dt;

    // Smooth facing direction
    ent.dirX = lerp(ent.dirX, vx, clamp(GUARD_CFG.turnSmoothing * dt, 0, 1));
    ent.dirY = lerp(ent.dirY, vy, clamp(GUARD_CFG.turnSmoothing * dt, 0, 1));
    return d < 6; // reached
  }

  function updateGuard(g, dt) {
    const sees = canGuardSeePlayer(g);

    if (sees) {
      g.lastSeenX = player.x;
      g.lastSeenY = player.y;
      g.timeSinceSeen = 0;
      if (g.state !== "CHASE") g.state = "CHASE";
    } else {
      g.timeSinceSeen += dt;
    }

    if (g.state === "PATROL") {
      const wp = g.waypoints[g.wpIndex];
      const reached = moveTowards(g, wp.x, wp.y, GUARD_CFG.patrolSpeed, dt);
      resolveCircleVsMap(g);
      if (reached) g.wpIndex = (g.wpIndex + 1) % g.waypoints.length;

      // If recently saw player, state would have changed above.
    }

    else if (g.state === "CHASE") {
      // Chase last known position (updates live when seeing player)
      moveTowards(g, g.lastSeenX, g.lastSeenY, GUARD_CFG.chaseSpeed, dt);
      resolveCircleVsMap(g);

      // Lose sight grace window → SEARCH
      if (g.timeSinceSeen > GUARD_CFG.loseSightGrace) {
        g.state = "SEARCH";
        g.searchTimer = GUARD_CFG.searchDuration;
      }
    }

    else if (g.state === "SEARCH") {
      // Go to last seen position, then linger
      const atLast = moveTowards(g, g.lastSeenX, g.lastSeenY, GUARD_CFG.patrolSpeed, dt);
      resolveCircleVsMap(g);

      if (atLast) {
        g.searchTimer -= dt;
        // Optional: rotate/scan
        const t = now() * 0.001;
        g.dirX = Math.cos(t * 2);
        g.dirY = Math.sin(t * 2);
        if (g.searchTimer <= 0) {
          g.state = "PATROL";
        }
      }
    }
  }

  // -----------------------------
  // 9) Damage + interactions
  // -----------------------------
  function updateDamage(dt) {
    if (player.invuln > 0) player.invuln -= dt;

    // Apply DPS if in any guard cone AND visible
    let takingDamage = false;

    for (const g of guards) {
      // If player is invisible, guards cannot see them
      if (player.invisible > 0) continue;

      // Check "in cone + LoS" again for damage (same as detection)
      if (canGuardSeePlayer(g)) {
        takingDamage = true;
        player.hp -= GUARD_CFG.dps * dt;
      }
    }

    if (takingDamage && player.invuln <= 0) {
      // small visual feedback — you can improve with screen vignette / sound
      canvas.classList.add("dangerFlash");
      setTimeout(() => canvas.classList.remove("dangerFlash"), 120);
      player.invuln = PLAYER_CFG.invulnAfterHit;
    }

    player.hp = clamp(player.hp, 0, PLAYER_CFG.maxHP);
  }

  function updatePowerups(dt) {
    // Spawn management
    powerupSpawnTimer -= dt;
    if (powerupSpawnTimer <= 0) {
      powerupSpawnTimer = POWERUP_CFG.spawnInterval;
      spawnPowerup();
    }

    // TTL + pickup
    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      p.ttl -= dt;
      if (p.ttl <= 0) {
        powerups.splice(i, 1);
        continue;
      }
      const d2p = dist2(p.x, p.y, player.x, player.y);
      if (d2p <= POWERUP_CFG.pickupRadius * POWERUP_CFG.pickupRadius) {
        applyPowerup(p.type);
        // reward for collecting
        player.score += Math.floor(10 * player.scoreMul);
        powerups.splice(i, 1);
      }
    }

    if (player.invisible > 0) player.invisible = Math.max(0, player.invisible - dt);
  }

  // -----------------------------
  // 10) Player movement
  // -----------------------------
  function updatePlayer(dt) {
    const mv = getMoveVector();
    const speed = player.speed * player.speedMul;
    player.x += mv.x * speed * dt;
    player.y += mv.y * speed * dt;

    resolveCircleVsMap(player);
  }

  // -----------------------------
  // 11) Objective / game state
  // -----------------------------
  let gameTime = GAME.timeLimit;
  let gameOver = false;
  let win = false;

  function checkEndConditions() {
    if (player.score >= GAME.targetScore) {
      gameOver = true;
      win = true;
    } else if (gameTime <= 0) {
      gameOver = true;
      win = false;
    } else if (player.hp <= 0) {
      gameOver = true;
      win = false;
    }
  }

  // -----------------------------
  // 12) Rendering
  // -----------------------------
  function drawMap() {
    for (let y = 0; y < MAP_H; y++) {
      for (let x = 0; x < MAP_W; x++) {
        const t = map[y][x];
        if (t === 1) {
          ctx.fillStyle = "#1f2a37";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        } else {
          ctx.fillStyle = "#0f1621";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        }
      }
    }
  }

  function drawPlayer() {
    ctx.save();
    if (player.invisible > 0) ctx.globalAlpha = 0.5;

    ctx.beginPath();
    ctx.fillStyle = "#7ee787";
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawGuard(g) {
    // Vision cone
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = (g.state === "CHASE") ? "#ff7b72" : "#79c0ff";

    const dir = norm(g.dirX, g.dirY);
    const a0 = Math.atan2(dir.y, dir.x);
    const a1 = a0 - GUARD_CFG.coneHalfAngle;
    const a2 = a0 + GUARD_CFG.coneHalfAngle;

    ctx.beginPath();
    ctx.moveTo(g.x, g.y);
    ctx.arc(g.x, g.y, GUARD_CFG.visionRange, a1, a2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Guard body
    ctx.beginPath();
    ctx.fillStyle = (g.state === "CHASE") ? "#ff7b72" : "#c9d1d9";
    ctx.arc(g.x, g.y, g.radius, 0, Math.PI*2);
    ctx.fill();

    // Facing dot
    const f = norm(g.dirX, g.dirY);
    ctx.beginPath();
    ctx.fillStyle = "#0b0f14";
    ctx.arc(g.x + f.x * 8, g.y + f.y * 8, 3, 0, Math.PI*2);
    ctx.fill();
  }

  function drawPowerups() {
    for (const p of powerups) {
      // simple icon color by type
      let c = "#a5d6ff";
      if (p.type === "HEAL") c = "#7ee787";
      if (p.type === "SPEED") c = "#d2a8ff";
      if (p.type === "SCOREX2") c = "#ffa657";
      if (p.type === "INVIS") c = "#8b949e";

      // Pulsing effect based on TTL
      const pulse = 0.7 + 0.3 * Math.sin((POWERUP_CFG.ttl - p.ttl) * 6);
      ctx.save();
      ctx.globalAlpha = 0.9 * pulse;

      ctx.beginPath();
      ctx.fillStyle = c;
      ctx.arc(p.x, p.y, 9, 0, Math.PI*2);
      ctx.fill();

      // TTL ring
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = c;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, -Math.PI/2, -Math.PI/2 + (p.ttl / POWERUP_CFG.ttl) * Math.PI*2);
      ctx.stroke();

      ctx.restore();
    }
  }

  function drawOverlay() {
    if (!gameOver) return;
    ctx.save();
    ctx.globalAlpha = 0.78;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;

    ctx.fillStyle = "#e6edf3";
    ctx.font = "bold 36px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(win ? "MISSION COMPLETE" : "MISSION FAILED", canvas.width/2, canvas.height/2 - 10);

    ctx.font = "16px system-ui";
    ctx.fillText("Refresh to try again (or wire up a reset button).", canvas.width/2, canvas.height/2 + 26);
    ctx.restore();
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap();
    drawPowerups();
    for (const g of guards) drawGuard(g);
    drawPlayer();
    drawOverlay();
  }

  // -----------------------------
  // 13) HUD update
  // -----------------------------
  function updateHUD() {
    UI.score.textContent = String(player.score);
    UI.target.textContent = String(GAME.targetScore);
    UI.time.textContent = gameTime.toFixed(1);
    UI.hpBar.style.width = `${(player.hp / PLAYER_CFG.maxHP) * 100}%`;
    UI.hpBar.style.background = (player.hp < 35) ? "#ff7b72" : "#2f81f7";
  }

  // -----------------------------
  // 14) Game loop
  // -----------------------------
  let lastT = performance.now();

  function tick(t) {
    const dt = clamp((t - lastT) / 1000, 0, 0.033); // cap dt (stability)
    lastT = t;

    if (!gameOver) {
      gameTime -= dt;

      updatePlayer(dt);
      for (const g of guards) updateGuard(g, dt);
      updatePowerups(dt);
      updateDamage(dt);

      // Passive score trickle encourages motion
      player.score += dt * 1.5 * player.scoreMul;

      checkEndConditions();
    }

    updateHUD();
    render();
    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
