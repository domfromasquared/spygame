<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Top-Down Stealth (Power-ups = Points Only)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f14; color:#e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { display:flex; gap:16px; padding:16px; align-items:flex-start; flex-wrap:wrap; }
    canvas { background:#0f1621; border:1px solid #243244; border-radius:12px; }
    .panel { width: 280px; }
    .hud { padding:12px; border:1px solid #243244; border-radius:12px; background:#0f1621; }
    .row { display:flex; justify-content:space-between; margin:8px 0; }
    .bar { height:10px; background:#243244; border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:100%; background:#2f81f7; }
    .hint { opacity:0.85; font-size: 0.9rem; line-height:1.35; margin-top:12px; }
    button { width:100%; margin-top:12px; padding:10px 12px; border-radius:10px; border:1px solid #243244; background:#111a26; color:#e6edf3; cursor:pointer; }
    button:hover { filter: brightness(1.1); }
    .flash { animation: flash 140ms ease-in-out; }
    @keyframes flash { from { filter: brightness(1.8); } to { filter: brightness(1); } }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="800" height="544"></canvas>

  <div class="panel">
    <div class="hud" id="hud">
      <div class="row"><div>Score</div><div id="score">0</div></div>
      <div class="row"><div>Target</div><div id="target">150</div></div>
      <div class="row"><div>Time</div><div id="time">75.0</div></div>

      <div style="margin-top:10px;">Health</div>
      <div class="bar"><div id="hpBar"></div></div>

      <div class="row" style="margin-top:10px;"><div>Power-ups on map</div><div id="pcount">0</div></div>

      <button id="restart">Restart</button>

      <div class="hint">
        Move: WASD / Arrow Keys<br/>
        Avoid flashlight conesâ€”standing in them drains health.<br/>
        Guards chase only after spotting you and give up after losing line-of-sight.<br/>
        <b>Score only comes from collecting power-ups.</b>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // =============================
  // Utilities
  // =============================
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax, ay, bx, by) => {
    const dx = bx - ax, dy = by - ay;
    return dx*dx + dy*dy;
  };
  const norm = (x, y) => {
    const l = Math.hypot(x, y) || 1;
    return { x: x / l, y: y / l };
  };
  const dot = (ax, ay, bx, by) => ax*bx + ay*by;
  const lerp = (a, b, t) => a + (b - a) * t;

  // =============================
  // Canvas / UI
  // =============================
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const UI = {
    hud: document.getElementById("hud"),
    score: document.getElementById("score"),
    target: document.getElementById("target"),
    time: document.getElementById("time"),
    hpBar: document.getElementById("hpBar"),
    pcount: document.getElementById("pcount"),
    restart: document.getElementById("restart"),
  };

  // =============================
  // Config
  // =============================
  const TILE = 32;
  const MAP_W = 25;
  const MAP_H = 17;

  const GAME_CFG = {
    targetScore: 150,
    timeLimit: 75,          // seconds
    maxHP: 100,
  };

  const PLAYER_CFG = {
    radius: 12,
    speed: 170,             // px/sec
    damageGrace: 0.10,      // seconds of cone contact before DPS starts
  };

  const GUARD_CFG = {
    radius: 12,
    patrolSpeed: 95,
    chaseSpeed: 140,
    visionRange: 220,
    coneHalfAngle: Math.PI / 7,   // ~25.7 degrees
    dps: 26,                      // damage per second while visible in cone
    loseSightGrace: 1.2,          // seconds after losing sight -> SEARCH
    searchDuration: 2.0,          // seconds to linger/scan at last seen
    turnSmoothing: 10,
    patrolMode: "PINGPONG",       // "LOOP" or "PINGPONG"
  };

  const POWERUP_CFG = {
    spawnInterval: 2.8,      // seconds between spawn attempts
    maxOnMap: 3,             // cap active pickups
    ttl: 7.0,                // seconds before despawn
    pickupRadius: 18,
    minSpawnDistFromPlayer: 2.5 * TILE,
  };

  const DEBUG = {
    drawUnreachableTint: false, // set true to visualize unreachable areas
    drawReachableTint: false,
    drawGuardPaths: false,
  };

  // =============================
  // Map (1 = wall, 0 = floor)
  // Includes unreachable floor islands (intentionally).
  // =============================
  const mapRows = [
    "1111111111111111111111111",
    "1000000000000010000000001",
    "1011110111111010111111101",
    "1010000100000010100000101",
    "1010111101111110101111101",
    "1010100001000000101000001",
    "1010101111011111101011111",
    "1000101000010000001010001",
    "1111101011110111111010111",
    "1000001010000100000010001",
    "1011111010111101111111101",
    "1010000010100001000000001",
    "1010111110101111011111101",
    "1010000000100000010000001",
    "1011111111111111110111101",
    "1000000000000000000000001", // bottom corridor
    "1111111111111111111111111",
  ];
  const map = mapRows.map(r => r.split("").map(c => c === "1" ? 1 : 0));

  const isWallTile = (tx, ty) => {
    if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return true;
    return map[ty][tx] === 1;
  };
  const worldToTile = (x, y) => ({ tx: Math.floor(x / TILE), ty: Math.floor(y / TILE) });

  // =============================
  // Line-of-sight (simple sampling)
  // =============================
  function hasLineOfSight(ax, ay, bx, by) {
    const dx = bx - ax, dy = by - ay;
    const d = Math.hypot(dx, dy);
    if (d < 1) return true;

    const steps = Math.ceil(d / 8);
    const sx = dx / steps, sy = dy / steps;

    let x = ax, y = ay;
    for (let i = 0; i < steps; i++) {
      const { tx, ty } = worldToTile(x, y);
      if (isWallTile(tx, ty)) return false;
      x += sx; y += sy;
    }
    return true;
  }

  // =============================
  // Collision: circle vs map tiles
  // =============================
  function resolveCircleVsMap(ent) {
    const r = ent.radius;

    const minTx = Math.floor((ent.x - r) / TILE);
    const maxTx = Math.floor((ent.x + r) / TILE);
    const minTy = Math.floor((ent.y - r) / TILE);
    const maxTy = Math.floor((ent.y + r) / TILE);

    for (let ty = minTy; ty <= maxTy; ty++) {
      for (let tx = minTx; tx <= maxTx; tx++) {
        if (!isWallTile(tx, ty)) continue;

        const left = tx * TILE, top = ty * TILE;
        const right = left + TILE, bottom = top + TILE;

        const cx = clamp(ent.x, left, right);
        const cy = clamp(ent.y, top, bottom);

        const dx = ent.x - cx, dy = ent.y - cy;
        const d2 = dx*dx + dy*dy;
        if (d2 < r*r) {
          const d = Math.sqrt(d2) || 0.0001;
          const push = (r - d);
          ent.x += (dx / d) * push;
          ent.y += (dy / d) * push;
        }
      }
    }
  }

  // =============================
  // Input
  // =============================
  const keys = new Set();
  window.addEventListener("keydown", (e) => keys.add(e.key.toLowerCase()));
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  function getMoveVector() {
    let x = 0, y = 0;
    if (keys.has("w") || keys.has("arrowup")) y -= 1;
    if (keys.has("s") || keys.has("arrowdown")) y += 1;
    if (keys.has("a") || keys.has("arrowleft")) x -= 1;
    if (keys.has("d") || keys.has("arrowright")) x += 1;

    if (x === 0 && y === 0) return { x: 0, y: 0 };
    return norm(x, y);
  }

  // =============================
  // Reachability: BFS from player start
  // Ensures power-ups only spawn in accessible areas.
  // =============================
  function computeReachableFrom(startX, startY) {
    const start = worldToTile(startX, startY);
    const reachable = Array.from({ length: MAP_H }, () => Array(MAP_W).fill(false));
    const q = [{ tx: start.tx, ty: start.ty }];
    reachable[start.ty][start.tx] = true;

    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    while (q.length) {
      const { tx, ty } = q.shift();
      for (const d of dirs) {
        const nx = tx + d.x, ny = ty + d.y;
        if (nx < 0 || ny < 0 || nx >= MAP_W || ny >= MAP_H) continue;
        if (reachable[ny][nx]) continue;
        if (isWallTile(nx, ny)) continue;
        reachable[ny][nx] = true;
        q.push({ tx: nx, ty: ny });
      }
    }

    const tiles = [];
    for (let y = 0; y < MAP_H; y++) {
      for (let x = 0; x < MAP_W; x++) {
        if (reachable[y][x]) tiles.push({ tx: x, ty: y });
      }
    }
    return { reachable, tiles };
  }

  // =============================
  // Entities / Game State
  // =============================
  let player, guards, powerups, floaters, REACH, gameTime, gameOver, win;

  function makeGuard(x, y, waypoints) {
    return {
      x, y,
      radius: GUARD_CFG.radius,
      state: "PATROL", // PATROL | CHASE | SEARCH
      waypoints,
      wpIndex: 0,
      wpDir: 1,        // for pingpong
      dirX: 1, dirY: 0,
      lastSeenX: x, lastSeenY: y,
      timeSinceSeen: 999,
      searchTimer: 0,
    };
  }

  // Points-only powerups with rarity tiers.
  function randomPointsValue() {
    const r = Math.random();
    if (r < 0.70) return 10;   // common
    if (r < 0.93) return 20;   // uncommon
    return 50;                // rare
  }

  function restart() {
    player = {
      x: 2.5 * TILE,
      y: 2.5 * TILE,
      radius: PLAYER_CFG.radius,
      speed: PLAYER_CFG.speed,
      hp: GAME_CFG.maxHP,
      score: 0,
      coneContact: 0, // how long continuously in cone
    };

    guards = [
      makeGuard(18.5*TILE, 2.5*TILE, [
        {x:18.5*TILE, y:2.5*TILE},
        {x:22.5*TILE, y:2.5*TILE},
        {x:22.5*TILE, y:6.5*TILE},
        {x:18.5*TILE, y:6.5*TILE},
      ]),
      makeGuard(7.5*TILE, 12.5*TILE, [
        {x:7.5*TILE, y:12.5*TILE},
        {x:11.5*TILE, y:12.5*TILE},
        {x:11.5*TILE, y:15.5*TILE},
        {x:7.5*TILE, y:15.5*TILE},
      ]),
    ];

    powerups = [];
    floaters = []; // {x,y,text,ttl,vy}
    gameTime = GAME_CFG.timeLimit;
    gameOver = false;
    win = false;

    // Resolve player in case of spawn clipping
    resolveCircleVsMap(player);

    // Compute reachable tiles from player start.
    REACH = computeReachableFrom(player.x, player.y);

    // Seed initial pickups
    for (let i = 0; i < POWERUP_CFG.maxOnMap; i++) spawnPowerup(true);
    powerupSpawnTimer = POWERUP_CFG.spawnInterval * 0.6;
  }

  UI.restart.addEventListener("click", restart);

  // =============================
  // Power-up spawning (reachable only)
  // =============================
  let powerupSpawnTimer = 0;

  function randomReachablePosition() {
    // Try multiple candidates to satisfy distance constraints.
    for (let i = 0; i < 80; i++) {
      const t = REACH.tiles[Math.floor(Math.random() * REACH.tiles.length)];
      const x = (t.tx + 0.5) * TILE;
      const y = (t.ty + 0.5) * TILE;

      if (dist2(x, y, player.x, player.y) < POWERUP_CFG.minSpawnDistFromPlayer ** 2) continue;

      // avoid stacking on existing powerups
      let tooClose = false;
      for (const p of powerups) {
        if (dist2(x, y, p.x, p.y) < (TILE * 1.0) ** 2) { tooClose = true; break; }
      }
      if (tooClose) continue;

      // ensure not inside a wall by collision resolve "no move" check
      const test = { x, y, radius: 10 };
      const bx = test.x, by = test.y;
      resolveCircleVsMap(test);
      if (dist2(bx, by, test.x, test.y) > 1) continue;

      return { x, y };
    }

    // fallback
    const t = REACH.tiles[Math.floor(Math.random() * REACH.tiles.length)];
    return { x: (t.tx + 0.5) * TILE, y: (t.ty + 0.5) * TILE };
  }

  function spawnPowerup(force = false) {
    if (!force && powerups.length >= POWERUP_CFG.maxOnMap) return;

    const pos = randomReachablePosition();
    const points = randomPointsValue();

    powerups.push({
      x: pos.x,
      y: pos.y,
      ttl: POWERUP_CFG.ttl,
      points,
    });
  }

  function addFloater(x, y, text) {
    floaters.push({ x, y, text, ttl: 0.9, vy: -28 });
  }

  // =============================
  // Guard vision / behavior
  // =============================
  function canGuardSeePlayer(g) {
    const vx = player.x - g.x;
    const vy = player.y - g.y;
    const d = Math.hypot(vx, vy);

    if (d > GUARD_CFG.visionRange) return false;

    const v = { x: vx / (d || 1), y: vy / (d || 1) };
    const dir = norm(g.dirX, g.dirY);

    const c = clamp(dot(v.x, v.y, dir.x, dir.y), -1, 1);
    const angle = Math.acos(c);
    if (angle > GUARD_CFG.coneHalfAngle) return false;

    return hasLineOfSight(g.x, g.y, player.x, player.y);
  }

  function moveTowards(ent, tx, ty, speed, dt) {
    const dx = tx - ent.x, dy = ty - ent.y;
    const d = Math.hypot(dx, dy);
    if (d < 0.001) return true;

    const vx = dx / d, vy = dy / d;
    ent.x += vx * speed * dt;
    ent.y += vy * speed * dt;

    // smooth facing
    ent.dirX = lerp(ent.dirX, vx, clamp(GUARD_CFG.turnSmoothing * dt, 0, 1));
    ent.dirY = lerp(ent.dirY, vy, clamp(GUARD_CFG.turnSmoothing * dt, 0, 1));

    return d < 6;
  }

  function advanceWaypoint(g) {
    if (GUARD_CFG.patrolMode === "LOOP") {
      g.wpIndex = (g.wpIndex + 1) % g.waypoints.length;
      return;
    }

    // PINGPONG
    g.wpIndex += g.wpDir;
    if (g.wpIndex >= g.waypoints.length) {
      g.wpIndex = g.waypoints.length - 2;
      g.wpDir = -1;
    } else if (g.wpIndex < 0) {
      g.wpIndex = 1;
      g.wpDir = 1;
    }
  }

  function updateGuard(g, dt) {
    const sees = canGuardSeePlayer(g);

    if (sees) {
      g.lastSeenX = player.x;
      g.lastSeenY = player.y;
      g.timeSinceSeen = 0;
      if (g.state !== "CHASE") g.state = "CHASE";
    } else {
      g.timeSinceSeen += dt;
    }

    if (g.state === "PATROL") {
      const wp = g.waypoints[g.wpIndex];
      const reached = moveTowards(g, wp.x, wp.y, GUARD_CFG.patrolSpeed, dt);
      resolveCircleVsMap(g);
      if (reached) advanceWaypoint(g);
    } else if (g.state === "CHASE") {
      moveTowards(g, g.lastSeenX, g.lastSeenY, GUARD_CFG.chaseSpeed, dt);
      resolveCircleVsMap(g);

      if (g.timeSinceSeen > GUARD_CFG.loseSightGrace) {
        g.state = "SEARCH";
        g.searchTimer = GUARD_CFG.searchDuration;
      }
    } else if (g.state === "SEARCH") {
      const atLast = moveTowards(g, g.lastSeenX, g.lastSeenY, GUARD_CFG.patrolSpeed, dt);
      resolveCircleVsMap(g);

      if (atLast) {
        g.searchTimer -= dt;
        // slow scanning rotation
        const t = performance.now() * 0.001;
        g.dirX = Math.cos(t * 1.8);
        g.dirY = Math.sin(t * 1.8);

        if (g.searchTimer <= 0) {
          g.state = "PATROL";
        }
      }
    }
  }

  // =============================
  // Core Updates
  // =============================
  function updatePlayer(dt) {
    const mv = getMoveVector();
    player.x += mv.x * player.speed * dt;
    player.y += mv.y * player.speed * dt;
    resolveCircleVsMap(player);
  }

  function updatePowerups(dt) {
    // Spawn timer (maintain maxOnMap)
    powerupSpawnTimer -= dt;
    if (powerupSpawnTimer <= 0) {
      powerupSpawnTimer = POWERUP_CFG.spawnInterval;
      if (powerups.length < POWERUP_CFG.maxOnMap) spawnPowerup();
    }

    // TTL & pickup
    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      p.ttl -= dt;
      if (p.ttl <= 0) {
        powerups.splice(i, 1);
        continue;
      }

      if (dist2(p.x, p.y, player.x, player.y) <= POWERUP_CFG.pickupRadius ** 2) {
        player.score += p.points;
        addFloater(p.x, p.y - 10, `+${p.points}`);
        UI.hud.classList.add("flash");
        setTimeout(() => UI.hud.classList.remove("flash"), 120);
        powerups.splice(i, 1);
      }
    }
  }

  function updateFloaters(dt) {
    for (let i = floaters.length - 1; i >= 0; i--) {
      const f = floaters[i];
      f.ttl -= dt;
      f.y += f.vy * dt;
      if (f.ttl <= 0) floaters.splice(i, 1);
    }
  }

  function updateDamage(dt) {
    // Cone contact / damage model:
    // If player is seen by ANY guard right now, build contact timer; after grace, apply DPS.
    let seenNow = false;
    for (const g of guards) {
      if (canGuardSeePlayer(g)) { seenNow = true; break; }
    }

    if (seenNow) {
      player.coneContact += dt;
      if (player.coneContact >= PLAYER_CFG.damageGrace) {
        player.hp -= GUARD_CFG.dps * dt;
        canvas.classList.add("flash");
        setTimeout(() => canvas.classList.remove("flash"), 90);
      }
    } else {
      player.coneContact = 0;
    }

    player.hp = clamp(player.hp, 0, GAME_CFG.maxHP);
  }

  function checkEndConditions() {
    if (player.score >= GAME_CFG.targetScore) {
      gameOver = true;
      win = true;
    } else if (gameTime <= 0) {
      gameOver = true;
      win = false;
    } else if (player.hp <= 0) {
      gameOver = true;
      win = false;
    }
  }

  // =============================
  // Rendering
  // =============================
  function drawMap() {
    for (let y = 0; y < MAP_H; y++) {
      for (let x = 0; x < MAP_W; x++) {
        const t = map[y][x];
        if (t === 1) {
          ctx.fillStyle = "#1f2a37";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        } else {
          ctx.fillStyle = "#0f1621";
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        }
      }
    }

    if (DEBUG.drawUnreachableTint && REACH) {
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#ff7b72";
      for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
          if (map[y][x] === 0 && !REACH.reachable[y][x]) {
            ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          }
        }
      }
      ctx.restore();
    }

    if (DEBUG.drawReachableTint && REACH) {
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = "#79c0ff";
      for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
          if (REACH.reachable[y][x]) ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        }
      }
      ctx.restore();
    }
  }

  function drawGuardPath(g) {
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.strokeStyle = "#79c0ff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(g.waypoints[0].x, g.waypoints[0].y);
    for (let i = 1; i < g.waypoints.length; i++) ctx.lineTo(g.waypoints[i].x, g.waypoints[i].y);
    if (GUARD_CFG.patrolMode === "LOOP") ctx.lineTo(g.waypoints[0].x, g.waypoints[0].y);
    ctx.stroke();
    ctx.restore();
  }

  function drawGuard(g) {
    if (DEBUG.drawGuardPaths) drawGuardPath(g);

    // Vision cone
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = (g.state === "CHASE") ? "#ff7b72" : "#79c0ff";
    const dir = norm(g.dirX, g.dirY);
    const a0 = Math.atan2(dir.y, dir.x);
    const a1 = a0 - GUARD_CFG.coneHalfAngle;
    const a2 = a0 + GUARD_CFG.coneHalfAngle;

    ctx.beginPath();
    ctx.moveTo(g.x, g.y);
    ctx.arc(g.x, g.y, GUARD_CFG.visionRange, a1, a2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Body
    ctx.beginPath();
    ctx.fillStyle = (g.state === "CHASE") ? "#ff7b72" : "#c9d1d9";
    ctx.arc(g.x, g.y, g.radius, 0, Math.PI*2);
    ctx.fill();

    // Facing dot
    const f = norm(g.dirX, g.dirY);
    ctx.beginPath();
    ctx.fillStyle = "#0b0f14";
    ctx.arc(g.x + f.x * 8, g.y + f.y * 8, 3, 0, Math.PI*2);
    ctx.fill();
  }

  function drawPlayer() {
    // Spy
    ctx.beginPath();
    ctx.fillStyle = "#7ee787";
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
    ctx.fill();

    // Direction hint (based on movement keys)
    const mv = getMoveVector();
    if (mv.x !== 0 || mv.y !== 0) {
      ctx.beginPath();
      ctx.fillStyle = "#0b0f14";
      ctx.arc(player.x + mv.x * 8, player.y + mv.y * 8, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawPowerups() {
    for (const p of powerups) {
      // Color by rarity
      let c = "#a5d6ff"; // common-ish
      if (p.points === 20) c = "#ffa657";
      if (p.points === 50) c = "#d2a8ff";

      const lifeRatio = clamp(p.ttl / POWERUP_CFG.ttl, 0, 1);
      const pulse = 0.75 + 0.25 * Math.sin((POWERUP_CFG.ttl - p.ttl) * 7);

      ctx.save();
      ctx.globalAlpha = 0.95 * pulse;

      // core
      ctx.beginPath();
      ctx.fillStyle = c;
      ctx.arc(p.x, p.y, 9, 0, Math.PI*2);
      ctx.fill();

      // outer ring showing TTL
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = c;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, -Math.PI/2, -Math.PI/2 + lifeRatio * Math.PI*2);
      ctx.stroke();

      // point label
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#0b0f14";
      ctx.font = "bold 11px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(p.points), p.x, p.y);

      ctx.restore();
    }
  }

  function drawFloaters() {
    for (const f of floaters) {
      const a = clamp(f.ttl / 0.9, 0, 1);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = "#e6edf3";
      ctx.font = "bold 14px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(f.text, f.x, f.y);
      ctx.restore();
    }
  }

  function drawOverlay() {
    if (!gameOver) return;

    ctx.save();
    ctx.globalAlpha = 0.78;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#e6edf3";
    ctx.textAlign = "center";

    ctx.font = "bold 40px system-ui";
    ctx.fillText(win ? "MISSION COMPLETE" : "MISSION FAILED", canvas.width/2, canvas.height/2 - 14);

    ctx.font = "16px system-ui";
    const msg = win
      ? "You hit the target score. Nice work."
      : (player.hp <= 0 ? "You took too much damage." : "You ran out of time.");
    ctx.fillText(msg, canvas.width/2, canvas.height/2 + 18);

    ctx.font = "14px system-ui";
    ctx.fillText("Press Restart to try again.", canvas.width/2, canvas.height/2 + 42);

    ctx.restore();
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap();
    drawPowerups();
    for (const g of guards) drawGuard(g);
    drawPlayer();
    drawFloaters();
    drawOverlay();
  }

  // =============================
  // HUD
  // =============================
  function updateHUD() {
    UI.score.textContent = String(Math.floor(player.score));
    UI.target.textContent = String(GAME_CFG.targetScore);
    UI.time.textContent = gameTime.toFixed(1);
    UI.pcount.textContent = String(powerups.length);

    const hpPct = (player.hp / GAME_CFG.maxHP) * 100;
    UI.hpBar.style.width = `${hpPct}%`;
    UI.hpBar.style.background = (player.hp < 35) ? "#ff7b72" : "#2f81f7";
  }

  // =============================
  // Main Loop
  // =============================
  let lastT = performance.now();

  function tick(t) {
    const dt = clamp((t - lastT) / 1000, 0, 0.033);
    lastT = t;

    if (!gameOver) {
      gameTime -= dt;

      updatePlayer(dt);
      for (const g of guards) updateGuard(g, dt);
      updatePowerups(dt);
      updateFloaters(dt);
      updateDamage(dt);

      checkEndConditions();
    }

    updateHUD();
    render();
    requestAnimationFrame(tick);
  }

  // Start
  restart();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
